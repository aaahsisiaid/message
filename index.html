<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>モダンLINE風チャット</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0; font-family: "Helvetica Neue", Arial, sans-serif;
      background: #e5ddd5; display: flex; flex-direction: column; height: 100vh;
    }
    header {
      background: #075e54; color: #fff;
      padding: 15px; text-align: center; font-size: 1.2rem;
    }
    #auth, #main {
      flex: 1; display: none; flex-direction: column;
      align-items: center; padding: 15px; overflow-y: auto;
    }
    #auth { display: flex; }
    input, button {
      font-size: 1rem; padding: 8px; margin: 4px 0;
      width: 100%; max-width: 300px; box-sizing: border-box;
      border-radius: 5px; border: 1px solid #ccc;
    }
    button.primary {
      background: #128c7e; color: white; border: none; cursor: pointer;
    }
    button.primary:hover {
      background: #0e755f;
    }
    #info, #friend-section, #chat, #notification-box {
      width: 100%; max-width: 500px;
      background: #fff; padding: 15px; border-radius: 10px;
      margin-bottom: 15px;
    }
    #friend-list button, #notification-list button {
      width: 100%; margin: 5px 0;
      text-align: left; background: #fff;
      border: 1px solid #ddd;
    }
    #messages {
      flex: 1; background: #fff; padding: 10px;
      border-radius: 10px; overflow-y: auto; margin-bottom: 10px; height: 300px;
    }
    .message {
      max-width: 70%; margin: 5px; padding: 10px;
      border-radius: 10px; word-break: break-word; position: relative;
    }
    .my-message {
      align-self: flex-end; background: #dcf8c6; border-bottom-right-radius: 0;
    }
    .other-message {
      align-self: flex-start; background: #fff; border-bottom-left-radius: 0;
    }
    .msg-meta {
      font-size: 0.7em; color: gray; margin-top: 4px;
    }
    #input-area {
      display: flex; margin-top: 10px;
    }
    #input-area input {
      flex: 1; margin-right: 5px;
      border-radius: 20px; border: 1px solid #ccc; padding: 10px;
    }
    #input-area button {
      width: 80px; border-radius: 20px;
    }
    #live-typing {
      font-size: 0.9em; color: #555; margin-bottom: 5px; text-align: center;
    }
    .delete-btn {
      position: absolute; top: 2px; right: 6px;
      font-size: 0.8em; cursor: pointer; color: red;
    }
    #jiffcy-mode {
      display: none; flex-direction: column;
      height: 400px; max-width: 500px;
      margin: 0 auto; background: #e1ffc7;
      border-radius: 10px; padding: 10px;
    }
    #call-status {
      font-weight: bold; margin-bottom: 10px;
    }
    #jiffcy-live {
      flex: 1; background: white; border-radius: 10px;
      padding: 10px; overflow-y: auto; word-break: break-word;
      margin-bottom: 10px;
    }
    #jiffcy-input {
      border-radius: 20px; padding: 10px;
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>
<header>モダンLINE風チャット</header>

<div id="auth">
  <input id="user" placeholder="ユーザー名" autocomplete="username" />
  <input id="pass" type="password" placeholder="パスワード" autocomplete="current-password" />
  <button class="primary" onclick="register()">新規登録</button>
  <button class="primary" onclick="login()">ログイン</button>
  <p id="auth-msg" style="color:red;"></p>
</div>

<div id="main">
  <div id="info">
    <span>ようこそ、<strong id="uname"></strong> さん<br>あなたのID：<strong id="uid"></strong></span>
    <button id="logout-btn" class="primary">ログアウト</button>
    <div id="my-qr"></div>
  </div>

  <div id="notification-box">
    <h4>通知</h4>
    <div id="notification-list"></div>
  </div>

  <div id="friend-section">
    <input id="friend-id" placeholder="相手のUID" />
    <button class="primary" onclick="addFriend()">友達追加</button>
    <button class="primary" onclick="startQR()">QR読み取り</button>
    <div id="qr-reader" style="display:none;"></div>
    <h4>友達リスト</h4>
    <div id="friend-list"></div>
  </div>

  <div id="chat">
    <div id="live-typing"></div>
    <div id="messages"></div>
    <div id="input-area">
      <input id="msg-text" placeholder="メッセージ" />
      <button id="send-btn" class="primary">送信</button>
    </div>
    <button id="call-toggle" class="primary" style="margin-top:10px;">文字通話開始</button>
  </div>

  <div id="jiffcy-mode">
    <div id="call-status">通話中</div>
    <div id="jiffcy-live"></div>
    <input id="jiffcy-input" type="text" placeholder="文字を入力すると相手にリアルタイム表示" />
    <button id="end-call-btn" class="primary" style="margin-top:10px;">通話終了</button>
  </div>
</div>

<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script src="https://unpkg.com/html5-qrcode"></script>
<script>
const firebaseConfig = {
  apiKey: "AIzaSyAEdcU79-YWhTVyuaRIKL8Y7uZ3Yujw0Fs",
  authDomain: "message-95d75.firebaseapp.com",
  projectId: "message-95d75",
  storageBucket: "message-95d75.appspot.com",
  messagingSenderId: "348991178331",
  appId: "1:348991178331:web:a504a5885f5df5491ba17e",
  measurementId: "G-LGM9GQK2HK"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

let currentUID = "", currentName = "", currentThread = "", subNames = {}, typingTimeout;
let inCall = false;
let callWithUID = "";

window.onload = () => {
  const u = localStorage.getItem("user");
  const p = localStorage.getItem("pass");
  if (u && p) {
    document.getElementById("user").value = u;
    document.getElementById("pass").value = p;
    login(true);
  }
};

function genUID(name) {
  const r = Math.random().toString(36).substr(2, 6);
  return `uid_${name}_${r}`;
}

async function register() {
  const u = document.getElementById("user").value.trim(),
    p = document.getElementById("pass").value;
  if (!u || !p) {
    showAuthMsg("全て入力してください");
    return;
  }
  const exists = await db.collection("users").where("username", "==", u).get();
  if (!exists.empty) {
    showAuthMsg("そのユーザー名は使えません");
    return;
  }
  const uid = genUID(u);
  await db.collection("users").add({ username: u, password: p, uid, friends: [], requests: [], subNames: {} });
  showAuthMsg("登録完了。ログインしてください。");
}

function showAuthMsg(msg) {
  document.getElementById("auth-msg").innerText = msg;
}

async function login(auto = false) {
  const u = document.getElementById("user").value.trim(),
    p = document.getElementById("pass").value;
  const snap = await db.collection("users")
    .where("username", "==", u).where("password", "==", p).get();
  if (snap.empty) {
    if (!auto) showAuthMsg("認証失敗");
    return;
  }
  const d = snap.docs[0];
  currentName = d.data().username;
  currentUID = d.data().uid;
  subNames = d.data().subNames || {};
  localStorage.setItem("user", u);
  localStorage.setItem("pass", p);
  document.getElementById("auth").style.display = "none";
  document.getElementById("main").style.display = "flex";
  document.getElementById("uname").innerText = currentName;
  document.getElementById("uid").innerText = currentUID;
  new QRCode(document.getElementById("my-qr"), { text: currentUID, width: 128, height: 128 });
  loadFriends();
  loadRequests();
}

document.getElementById("logout-btn").onclick = () => {
  localStorage.clear();
  location.reload();
};

async function addFriend() {
  const fid = document.getElementById("friend-id").value.trim();
  if (!fid || fid === currentUID) return alert("無効なID");

  const meSnap = await db.collection("users").where("uid", "==", currentUID).get();
  const youSnap = await db.collection("users").where("uid", "==", fid).get();
  if (youSnap.empty) return alert("相手が見つかりません");
  const myDoc = meSnap.docs[0];
  const yourDoc = youSnap.docs[0];
  const reqs = yourDoc.data().requests || [];

  if (reqs.includes(currentUID)) return alert("すでに申請済みです");

  reqs.push(currentUID);
  await db.collection("users").doc(yourDoc.id).update({ requests: reqs });
  alert("申請を送信しました");
}

async function loadRequests() {
  const meSnap = await db.collection("users").where("uid", "==", currentUID).get();
  const reqs = meSnap.docs[0].data().requests || [];
  const list = document.getElementById("notification-list");
  list.innerHTML = "";
  for (const uid of reqs) {
    const snap = await db.collection("users").where("uid", "==", uid).get();
    if (snap.empty) continue;
    const user = snap.docs[0].data();
    const btn = document.createElement("button");
    btn.textContent = `${user.username} さんから申請`;
    btn.onclick = async () => {
      const me = meSnap.docs[0], you = snap.docs[0];
      const myFr = me.data().friends || [], yourFr = you.data().friends || [];
      if (!myFr.includes(uid)) myFr.push(uid);
      if (!yourFr.includes(currentUID)) yourFr.push(currentUID);
      const myReqs = reqs.filter(id => id !== uid);
      await db.collection("users").doc(me.id).update({ friends: myFr, requests: myReqs });
      await db.collection("users").doc(you.id).update({ friends: yourFr });
      alert("承認しました！");
      loadRequests();
      loadFriends();
    };
    list.appendChild(btn);
  }
}

async function loadFriends() {
  const list = document.getElementById("friend-list");
  list.innerHTML = "";
  const snap = await db.collection("users").where("uid", "==", currentUID).get();
  const fr = snap.docs[0].data().friends || [];
  const added = new Set();
  for (const fid of fr) {
    if (added.has(fid)) continue;
    added.add(fid);
    const fSnap = await db.collection("users").where("uid", "==", fid).get();
    if (fSnap.empty) continue;
    const fdoc = fSnap.docs[0].data();
    const btn = document.createElement("button");
    const sub = subNames[fid] ? `（${subNames[fid]}）` : "";
    btn.innerText = fdoc.username + sub;
    btn.onclick = () => openChat(fid, fdoc.username);
    list.append(btn);
  }
}

function getThread(u1, u2) { return [u1, u2].sort().join("__"); }

function openChat(fid, fname) {
  currentThread = getThread(currentUID, fid);
  document.getElementById("messages").innerHTML = "";
  document.getElementById("msg-text").value = "";
  listenTyping(fid);
  db.collection("messages").doc(currentThread).collection("messages")
    .orderBy("timestamp").onSnapshot(ss => {
      const mdiv = document.getElementById("messages");
      mdiv.innerHTML = "";
      ss.forEach(d => {
        const m = d.data();
        const el = document.createElement("div");
        el.className = "message " + (m.uid === currentUID ? "my-message" : "other-message");
        if (m.deleted) {
          el.innerText = m.uid === currentUID ? "（送信を取り消しました）" : "（送信が取り消されました）";
        } else {
          el.innerHTML = `${m.text}<div class="msg-meta">${timeStr(m.timestamp)}${m.read ? "・既読" : ""}</div>`;
        }
        if (m.uid === currentUID && !m.deleted) {
          const del = document.createElement("span");
          del.className = "delete-btn";
          del.innerText = "❌";
          del.onclick = () => deleteMessage(d.id);
          el.appendChild(del);
        }
        mdiv.appendChild(el);
      });
      mdiv.scrollTop = mdiv.scrollHeight;
      markAsRead();
    });
}

function timeStr(ts) {
  if (!ts) return "";
  const d = ts.toDate();
  return `${d.getHours()}:${("0" + d.getMinutes()).slice(-2)}`;
}

function markAsRead() {
  const ref = db.collection("messages").doc(currentThread).collection("messages");
  ref.where("uid", "!=", currentUID).where("read", "==", false).get().then(snap => {
    snap.forEach(doc => {
      doc.ref.update({ read: true });
    });
  });
}

function deleteMessage(msgId) {
  const ref = db.collection("messages").doc(currentThread).collection("messages").doc(msgId);
  ref.update({ deleted: true });
}

document.getElementById("send-btn").onclick = () => {
  const t = document.getElementById("msg-text").value.trim();
  if (!t || !currentThread) return;
  db.collection("messages").doc(currentThread).collection("messages").add({
    uid: currentUID, text: t, timestamp: firebase.firestore.FieldValue.serverTimestamp(), read: false, deleted: false
  });
  db.collection("typing").doc(currentThread).set({ [currentUID]: "" });
  document.getElementById("msg-text").value = "";
};

document.getElementById("msg-text").addEventListener("input", e => {
  const txt = e.target.value;
  const typingRef = db.collection("typing").doc(currentThread);
  typingRef.set({ [currentUID]: txt }, { merge: true });

  if (typingTimeout) clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => {
    typingRef.set({ [currentUID]: "" }, { merge: true });
  }, 3000);
});

function listenTyping(fid) {
  const thread = getThread(currentUID, fid);
  db.collection("typing").doc(thread).onSnapshot(doc => {
    const d = doc.data();
    if (!d) return;
    for (const [uid, text] of Object.entries(d)) {
      if (uid !== currentUID && text) {
        document.getElementById("live-typing").innerText = `相手が入力中: ${text}`;
        return;
      }
    }
    document.getElementById("live-typing").innerText = "";
  });
}

function startQR() {
  document.getElementById("qr-reader").style.display = "block";
  new Html5Qrcode("qr-reader").start(
    { facingMode: "environment" },
    { fps: 10, qrbox: 250 },
    qr => { document.getElementById("friend-id").value = qr; alert("読み取り完了！"); }
  );
}

// ----- 文字通話モード（Jiffcy風UI） -----

document.getElementById("call-toggle").onclick = () => {
  if (!currentThread) return alert("友達を選択してください");
  const fid = currentThread.split("__").find(id => id !== currentUID);
  toggleCallMode(fid);
};

document.getElementById("end-call-btn").onclick = () => {
  endCall();
};

function toggleCallMode(targetUID) {
  if (!inCall) {
    callWithUID = targetUID;
    checkCallConsent(targetUID);
  } else {
    endCall();
  }
}

async function checkCallConsent(targetUID) {
  const callDoc = db.collection("calls").doc(getThread(currentUID, targetUID));
  const snap = await callDoc.get();

  if (!snap.exists) {
    await callDoc.set({
      requester: currentUID,
      responder: "",
      status: "requested",
    });
    listenCallStatus(callDoc);
  } else {
    const data = snap.data();
    if (data.status === "requested" && data.requester !== currentUID) {
      await callDoc.update({ responder: currentUID, status: "accepted" });
      enterCallMode();
    } else if (data.status === "accepted") {
      enterCallMode();
    } else {
      listenCallStatus(callDoc);
    }
  }
}

function listenCallStatus(callDoc) {
  callDoc.onSnapshot(doc => {
    const data = doc.data();
    if (!data) return;
    if (data.status === "accepted" && !inCall) {
      enterCallMode();
    }
    if (data.status === "ended") {
      exitCallMode();
    }
  });
}

function enterCallMode() {
  inCall = true;
  document.getElementById("chat").style.display = "none";
  document.getElementById("jiffcy-mode").style.display = "flex";
  document.getElementById("call-status").innerText = `通話中: ${callWithUID}`;
  listenCallTyping();
}

function exitCallMode() {
  inCall = false;
  callWithUID = "";
  document.getElementById("jiffcy-mode").style.display = "none";
  document.getElementById("chat").style.display = "flex";
  document.getElementById("live-typing").innerText = "";
  stopListenCallTyping();
}

async function endCall() {
  const callDoc = db.collection("calls").doc(getThread(currentUID, callWithUID));
  await callDoc.update({ status: "ended" });
  exitCallMode();
}

let callTypingUnsub = null;
function listenCallTyping() {
  const callDoc = db.collection("calls").doc(getThread(currentUID, callWithUID));
  callTypingUnsub = callDoc.collection("typing").doc("text").onSnapshot(doc => {
    if (!doc.exists) return;
    const data = doc.data();
    const otherUID = callWithUID === currentUID ? null : callWithUID;
    if (data[otherUID]) {
      document.getElementById("jiffcy-live").innerText = data[otherUID];
    }
  });
}

function stopListenCallTyping() {
  if (callTypingUnsub) {
    callTypingUnsub();
    callTypingUnsub = null;
  }
}

function sendCallTyping(text) {
  const callDoc = db.collection("calls").doc(getThread(currentUID, callWithUID));
  const update = {};
  update[currentUID] = text;
  callDoc.collection("typing").doc("text").set(update, { merge: true });
}

document.getElementById("jiffcy-input").addEventListener("input", e => {
  sendCallTyping(e.target.value);
});

</script>
</body>
</html>
